
class GA_BaseCardsDictionary extends GA_CardsDictionary {
  public function generateDeck(match: GA_GeneralDataCurrentMatch): SDeckDefinition {
    var deck_identifier: GA_DeckIdentifier = match.identifier;
    var seed: float = GA_identifierToInt(deck_identifier.value) as float;
    var rng: RandomNumberGenerator = this.rng(seed);
    var difficulty: GA_MatchDifficulty = this.getDifficultyFromSeed(rng);
    var points: GA_DeckPoints = this.getPointsFromSeed(rng);

    GALOG("generateDeck(), seed = " + seed + " difficulty = " + difficulty.value + " points = " + points.value);
    var rules: GA_FactionCardDictionary = this.rules(rng);
    
    return this.generateDeckFromRules(rng, difficulty, points, rules);
  }

  //////////////////////////////////////////////////////////////////////////////

  /**
   * This function can be overridden to return a custom ruleset generator.
   */
  function getRulesetGenerator(): GA_BaseRulesetGenerator {
    return new GA_VanillaRulesetGenerator in this;
  }

  function rules(rng: RandomNumberGenerator): GA_FactionCardDictionary {
    var faction: GA_VanillaFactionsIndex = this.getFactionFromSeed(rng);
    var generator: GA_BaseRulesetGenerator = this.getRulesetGenerator();
    var rules: GA_FactionCardDictionary;

    GALOG("rules(), faction = " + faction);

    switch (faction) {
      case GA_VFI_NorthernKingdom:
        rules = generator.generateNorthernKingdomRules();
        break;
      case GA_VFI_Nilfgaardian:
        rules = generator.generateNilfgaardianRules();
        break;
      case GA_VFI_Scoiatael:
        rules = generator.generateScoiataelRules();
        break;
      case GA_VFI_Monster:
        rules = generator.generateMonsterRules();
        break;
      case GA_VFI_Skellige:
        rules = generator.generateSkelligeRules();
        break;
    }

    return rules;
  }

  //////////////////////////////////////////////////////////////////////////////

  function rng(seed: float): RandomNumberGenerator {
    var rng: RandomNumberGenerator;

    rng = (new RandomNumberGenerator in thePlayer)
      .setSeed(seed as int)
      .useSeed(true);

    return rng;
  }

  //////////////////////////////////////////////////////////////////////////////

  public function getDifficultyFromSeed(rng: RandomNumberGenerator): GA_MatchDifficulty {
    return GA_MatchDifficulty(
      GA_rngRolls(GA_CONSTANTS_ENUM_DIFFCULTY_FROM_SEED_ROLL, rng, 10000, 0) as int
    );
  }

  public function getPointsFromSeed(rng: RandomNumberGenerator): GA_DeckPoints {
    return GA_DeckPoints(
      GA_rngRolls(GA_CONSTANTS_ENUM_POINTS_FROM_SEED_ROLL, rng, 100, 10) as int
    );
  }

  public function getFactionFromSeed(rng: RandomNumberGenerator): GA_VanillaFactionsIndex {
    var roll: int = GA_rngRolls(
      GA_CONSTANTS_ENUM_POINTS_FROM_SEED_ROLL,
      rng,
      EnumGetMin('GA_VanillaFactionsIndex'),
      EnumGetMax('GA_VanillaFactionsIndex') + 1
    ) as int;
    
    return roll as GA_VanillaFactionsIndex;
  }

  /**
   * Return all the cards that are smaller than the given difficulty
   */
  public function getAvailableCardEntriesForDifficulty(cards: array<GA_CardEntry>, difficulty: GA_MatchDifficulty): array<GA_CardEntry> {
    var filtered_cards: array<GA_CardEntry>;
    var i: int;

    for (i = 0; i < cards.Size(); i += 1) {
      if (cards[i].required_difficulty.value > difficulty.value) {
        continue;
      }

      filtered_cards.PushBack(cards[i]);
    }

    return filtered_cards;
  }

  /**
   * Return all the cards whose cost is lower than the given deck points
   */
  public function getAvailableCardEntriesForDeckPoints(cards: array<GA_CardEntry>, points: GA_DeckPoints): array<GA_CardEntry> {
    var filtered_cards: array<GA_CardEntry>;
    var i: int;

    for (i = 0; i < cards.Size(); i += 1) {
      if (cards[i].cost.value > points.value) {
        continue;
      }

      filtered_cards.PushBack(cards[i]);
    }

    return filtered_cards;
  }

  //////////////////////////////////////////////////////////////////////////////

  function generateDeckFromRules(rng: RandomNumberGenerator, difficulty: GA_MatchDifficulty, points: GA_DeckPoints, rules: GA_FactionCardDictionary): SDeckDefinition {
    var deck: SDeckDefinition;

    var leader: GA_CardEntry = this.generateDeckLeaderFromRules(rng, difficulty, points, rules);
    points.value -= leader.cost.value;
    deck.leaderIndex = leader.index;

    var unit: GA_CardEntry;
    while (true) {
      if (!this.generateDeckUnitFromRules(rng, difficulty, points, rules, unit)) {
        break;
      }

      deck.cardIndices.PushBack(unit.index);
      points.value -= unit.cost.value;
    }

    return deck;
  }

  function generateDeckLeaderFromRules(rng: RandomNumberGenerator, difficulty: GA_MatchDifficulty, points: GA_DeckPoints, rules: GA_FactionCardDictionary): GA_CardEntry {
    var entries: array<GA_CardEntry> = this.getAvailableCardEntriesForDeckPoints(
      this.getAvailableCardEntriesForDifficulty(rules.leader_cards, difficulty),
      points
    );

    var max: int = entries.Size();
    var index: int = GA_rngRolls(
      GA_CONSTANTS_ENUM_LEADER_FROM_SEED_ROLL,
      rng,
      max,
      0
    ) as int;

    return entries[index];
  }

  function generateDeckUnitFromRules(rng: RandomNumberGenerator, difficulty: GA_MatchDifficulty, points: GA_DeckPoints, rules: GA_FactionCardDictionary, out unit: GA_CardEntry): bool {
    var entries: array<GA_CardEntry> = this.getAvailableCardEntriesForDeckPoints(
      this.getAvailableCardEntriesForDifficulty(rules.unit_cards, difficulty),
      points
    );

    var max: int = entries.Size();
    if (max <= 0) {
      return false;
    }

    var index: int = GA_rngRolls(
      GA_CONSTANTS_ENUM_LEADER_FROM_SEED_ROLL,
      rng,
      max,
      0
    ) as int;

    unit = entries[index];
    return true;
  }
}


/**
 * A dictionnary of cards for a specific faction
 */
struct GA_FactionCardDictionary {
  var hero_cards: array<GA_CardEntry>;
  var leader_cards: array<GA_CardEntry>;
  var unit_cards: array<GA_CardEntry>;
}

/**
 * A dictionnary entry for one specific card
 */
struct GA_CardEntry {
  /**
   * The index for the card
   */
  var index: int;

  /**
   * The chance for this card to be picked by the generator,
   * a value in the [0;1] range where 0 means 0% chance and 1 means 100% chance
   */
  var chance: float;

  /**
   * The maximum amount of times this card will be added
   * to the deck if it is picked by the generator once.
   */
  var maximum: int;

  /**
   * The minimum amount of times this card will be added
   * to the deck if it is picked by the generator once.
   */
  var minimum: int;

  /**
   * Defines how many points in the GA_DeckPoints adding
   * this card will cost.
   */
  var cost: GA_DeckPoints;

  /**
   * Defines after what difficulty the card should start
   * appearing in decks
   */
  var required_difficulty: GA_MatchDifficulty;
}

enum GA_VanillaFactionsIndex {
  GA_VFI_NorthernKingdom = 0,
  GA_VFI_Nilfgaardian = 1,
  GA_VFI_Scoiatael = 2,
  GA_VFI_Monster = 3,
  GA_VFI_Skellige = 4
}
